/// # 宏
/// 
/// 宏（Macro）指的是Rust中一系列的功能：使用 macro_rules! 的声明（Declarative）宏，
/// 和三种过程（Procedural）宏：
/// 自定义 #[derive] 宏在结构体和枚举上指定通过 derive 属性添加的代码
/// 类属性（Attribute-like）宏定义可用于任意项的自定义属性
/// 类函数宏看起来像函数不过作用于作为参数传递的 token
///
/// 
/// # 宏和函数的区别
/// 
/// 宏是一种为写其他代码而写代码的的方式，即所谓的**元编程**（metaprogramming）。元编
/// 程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数扮演的角色。但宏有一些函
/// 数所没有的附加能力。
/// 
/// 一个函数签名必须声明函数参数个数和类型。相比之下，宏能够接收不同数量的参数：用一个
/// 参数调用 println!("hello") 或用两个参数调用 println!("hello {}", name) 。而且，
/// 宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。而函数则不行，
/// 因为函数是在运行时被调用，同时 trait 需要在编译时实现。
/// 
/// 实现宏不如实现函数的一面是宏定义要比函数定义更复杂，因为此时正在编写生成 Rust 代码
/// 的 Rust 代码。
/// 
/// 宏和函数的最后一个重要区别是：在一个文件里调用宏之前必须定义它，或将其引入作用域，而
/// 函数则可以在任何地方定义和调用。
/// 
/// 
/// # 使用 macro_rules! 的声明宏用于通用元编程
/// 
/// Rust 最常用的宏形式是声明宏。有时也被称为“macros by example”、“macro_rules! 宏”、
/// “marcos”。声明宏允许我们编写一些类似 Rust match 表达式的代码。

fn macros() {

}

#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}