/// R-B Tree 全称 Red-Black Tree，是一种特殊的二叉查找树。红黑树的每个节点上都有存储位
/// 表示节点的颜色，可以是红或黑.
/// 特性：
///     （1）每个节点或者是黑色，或者是红色。
///     （2）根节点是黑色。
///     （3）每个叶子节点 (NIL) 是黑色。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点]
///     （4）连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）。
///     （5）从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点。
///     （-）新加入到红黑树的节点为红色节点。
///
/// eg:
///                                  80[B]
///                    /                                 \
///                  40[R]                             120[R]
///            /               \                  /                 \
///          20[B]            60[B]            100[B]             140[B]
///         /    \           /     \          /      \         /           \
///       10[R]   NIL[B]  50[R]   NIL[B]   90[R]    NIL[B]  10[R]         30[R]
///     /     \          /     \          /     \          /     \       /     \
///  NIL[B] NIL[B]    NIL[B] NIL[B]    NIL[B] NIL[B]    NIL[B] NIL[B] NIL[B] NIL[B]
/// 
/// Tips：
///     （1）从根节点到叶子节点的最长路径不大于最短路径的2倍，
///             a.最短路径：从根节点到每个叶子节点的黑色节点数量是一样的，那么由黑色节点组
///             成的路径就是最短路径。
///             b.最长路径：若有红色节点，则必然有一个连接的黑色节点，当红色节点和黑色节点
///             数量相同时，就是最长路径，也就是黑色节点（或红色节点）数量*2。
///     （2）为什么新加入到红黑树中的节点为红色节点
///             - 当前红黑树中从根节点到每个叶子节点的黑色节点数量时一样的，此时假如新的是
///             黑色节点的话，比如破坏规则。
///             - 但加入红色节点缺不一定，除非其父节点就是红色节点，因此加入红色节点，破坏
///             规则的可能性小一些。
///     （3）红黑树的时间复杂度为：O(lgn) 
///     （4）红黑树的结构破坏后，维持平衡主要通过两种方式【变色】和【旋转】，【旋转】又分
///          为【左旋】和【右旋】，两种方式可相互结合。
///         - 左旋：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点
///         的左子节点。
///         eg:
///             PL               PL                  G
///           /   \             / |                /   \
///         C1     G     =>   C1   \   G    =>    PL   PR
///               / \               \ / \        /  \
///             C2  PR              C2  PR      C1  C2
/// 
///         - 右旋：顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的
///         右子节点。
///         eg:
///             G                  G                 PL
///           /   \                |  \            /   \
///         PL     PR     =>   PL  /  PR    =>    C1    G
///        / \                /  \/                    /  \
///       C1  C2             C1  C2                   C2  PR
/// 
/// 红黑树节点插入总结：
///     - 无需调整：当父节点为黑色时插入子节点
///     - 【变色】：
///             （1）空树插入根节点，将根节点红色变为黑色
///             （2）父节点和叔父节点都为红色
///     - 【旋转+变色】：
///             （1）父节点为红色左节点，叔父节点为黑色，插入左子节点，那么通过【左左节点旋转】
///             （2）父节点为红色左节点，叔父节点为黑色，插入右子节点，那么通过【左右节点旋转】
///             （3）父节点为红色右节点，叔父节点为黑色，插入左子节点，那么通过【右左节点旋转】
///             （4）父节点为红色右节点，叔父节点为黑色，插入右子节点，那么通过【右右节点旋转】
/// 
/// 红黑树节点删除总结：
///     - 删除的是根节点，则直接将根节点置为null;
///     - 待删除节点的左右子节点都为null，删除时将该节点置为null;
///     - 待删除节点的左右子节点有一个有值，则用有值的节点替换该节点即可；
///     - 待删除节点的左右子节点都不为null，则找前驱或者后继，将前驱或者后继的值复制到该节点中，然后删除前驱或者后继；
///     - 节点删除后可能会造成红黑树的不平衡，这时我们需通过【变色】+【旋转】的方式来调整，使之平衡。
/// 
/// 插入操作（自动平衡4种情况）：
///     （1）curr = root: 
///             a.新增curr，默认红色
///             b.修改curr颜色为黑色
///     （2）curr.parent = black: 新增curr，颜色为红色
///     （3）curr.parent = red and curr.uncle(相邻) = red: 
///             a.新增curr，默认红色
///             b.parent变成黑色
///             c.uncle变成黑色
///             d.grandparent变成红色
///             e.如果grandparent变红色导致不满足红黑树性质，将grandparent作为curr递归处理[1,2,3,4]情况。
///     （4）curr.parent = red and (curr.uncle = black or curr.uncle is Nil):
///             -1 curr,parent,grandparent三点一线:
///                 a.以parent为圆心，旋转grandparent
///                 b.变色parent和grandparent
///             -2 curr,parent,grandparent三角关系:
///                 a.以curr为圆心，旋转parent
///                 b.按（4）1-处理
/// 
/// 删除操作：
///     （1）被删除节点没有子节点：删除即可
///     （2）被删除节点只有一个子节点：
///             -1 删除节点为红色：
///                 a.直接拿子节点替换，并删除原节点
///                 b.以替换节点为curr进入自动平衡4种情况
///             -2 删除节点为黑色：
///                 -2-1 子节点为红色：
///                     a.直接拿子节点替换，并删除原节点
///                     b.并将作为替换节点的子节点变为黑色
///                 -2-2 子节点为黑色（最复杂情况）：
///                     a.子节点替换为父节点，并删除父节点 -> 替换后子节点变为curr
///                     -2-2-1 替换后子节点成为根节点：不需要调整
///                     -2-2-2 替换后子节点的父亲，兄弟，左右侄子节点都是黑色：
///                         a.把子节点的兄弟节点变为红色
///                         b.替换后子节点的父亲扮演子节点的角色,进入-2-2-[1-6]递归
///                     -2-2-3 替换后子节点的兄弟是红色：
///                         a.以兄弟节点为圆心，旋转父亲节点
///                         b.然后兄弟节点变为黑色，原先的父亲节点变为红色
///                         c.子节点curr还是以curr的身份，进入-2-2-[4-6]
///                     -2-2-4 替换后子节点的父亲节点是红色，兄弟节点和左右侄子节点是黑色：
///                         a.父亲节点变为黑色
///                         b.兄弟节点变为红色
///                     -2-2-5 替换后子节点的父亲节点P随意，兄弟节点B为黑色，且P.right=B, B.left左侄子节点是红色，B.right右侄子节点黑色：
///                         a.以兄弟节点为圆心，旋转左侄子节点
///                         b.兄弟节点变为红色
///                         c.原左侄子节点变为黑色
///                         d.进入-2-2-6
///                     -2-2-6 替换后子节点的父亲节点P随意，兄弟节点B为合适，且P.right=B, B.right右侄子节点是红色：
///                         a.以兄弟节点为圆心，旋转父节点
///                         b.兄弟节点和父节点的颜色交换
///                         c.右侄子节点变为黑色
///     （3）被删除节点有两个子节点：
///             a.找到右子树最小节点作为后续
///             b.将后续的值复制到要删除的节点
///             c.执行删除后续操作（后续操作不可能有两个孩子），后续作为被删除节点递归进入情况(1)-(2)

fn main() {
    
}
